name: Terraform + Lightsail Deploy

on:
  workflow_dispatch: {}
  workflow_run:
    workflows: ['Security checks']
    types: [completed]
    branches: [main]

permissions:
  id-token: write
  contents: read
  actions: read

concurrency:
  group: prod-deploy
  cancel-in-progress: false

env:
  AWS_REGION: eu-north-1
  SERVICE_NAME: lightscore-prod
  FRONTEND_PORT: '5000'
  BACKEND_PORT: '8000'

jobs:
  check-prerequisites:
    name: Verify CI and Security passed
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success'
    outputs:
      deploy-ready: ${{ steps.check.outputs.ready }}
    steps:
      - name: Check workflow prerequisites
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const sha = context.payload.workflow_run.head_sha;

            // Since we're triggered by Security completion, verify CI also passed
            const { data } = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, head_sha: sha, status: 'completed', per_page: 50
            });

            const findByName = (n) => data.workflow_runs.find(r => r.name === n);
            const ci = findByName('CI');
            const sec = findByName('Security checks');

            const ciPassed = !!ci && ci.conclusion === 'success';
            const secPassed = !!sec && sec.conclusion === 'success';

            core.info(`CI passed: ${ciPassed}`);
            core.info(`Security passed: ${secPassed}`);

            // Both must pass since we want security gates
            const ready = ciPassed && secPassed;
            core.setOutput('ready', String(ready));
            if (!ready) core.setFailed('Prerequisites not met: Both CI and Security must pass');

  terraform:
    name: Terraform apply (create/update Lightsail service)
    runs-on: ubuntu-latest
    needs: [check-prerequisites]
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && needs.check-prerequisites.outputs.deploy-ready == 'true')
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: gh-terraform

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init -input=false

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve -input=false

      - name: Verify Terraform deployment
        working-directory: ./terraform
        run: |
          terraform state list | grep -q '^aws_lightsail_container_service\.svc$'
          echo "‚úÖ Terraform deployment verified"

      - name: Output service URL
        id: svc
        working-directory: ./terraform
        run: |
          URL=$(terraform output -raw lightsail_service_url || true)
          echo "URL=$URL"
          echo "URL=$URL" >> $GITHUB_OUTPUT

  deploy:
    name: Build, push & deploy containers to Lightsail
    runs-on: ubuntu-latest
    needs: [check-prerequisites, terraform]
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && needs.check-prerequisites.outputs.deploy-ready == 'true')
    outputs:
      service_url: ${{ steps.deploy.outputs.URL }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: gh-deploy

      - name: Install lightsailctl with checksum verification
        run: |
          set -euo pipefail
          ARCH=linux-amd64
          BASE="https://s3.us-west-2.amazonaws.com/lightsailctl/latest/${ARCH}"

          TMP="$(mktemp -d)"
          curl --proto '=https' --tlsv1.2 --retry 3 -fsSLo "${TMP}/lightsailctl" "${BASE}/lightsailctl"

          # Try to download checksum file (AWS may not publish one)
          if curl --proto '=https' --tlsv1.2 --retry 3 -fsSLo "${TMP}/lightsailctl.sha256" "${BASE}/lightsailctl.sha256" 2>/dev/null; then
          cd "${TMP}"
          # If checksum file includes a filename, use as-is; else normalize to "<hash>  lightsailctl"
          if awk 'NF>=2{found=1} END{exit !found}' lightsailctl.sha256; then
              CHECKFILE="lightsailctl.sha256"
          else
              echo "$(tr -d ' \t\r\n' < lightsailctl.sha256)  lightsailctl" > sum.txt
              CHECKFILE="sum.txt"
          fi
          echo "‚úÖ Verifying checksum..."
          sha256sum -c "$CHECKFILE"
          else
          echo "‚ö†Ô∏è  No checksum file available from AWS, skipping verification"
          echo "    Binary: ${BASE}/lightsailctl"
          fi

          # Install to user bin (no sudo needed)
          mkdir -p "$HOME/.local/bin"
          mv "${TMP}/lightsailctl" "$HOME/.local/bin/lightsailctl"
          chmod +x "$HOME/.local/bin/lightsailctl"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          export PATH="$HOME/.local/bin:$PATH"

          # Sanity check - lightsailctl is meant to be invoked by AWS CLI, not directly
          command -v lightsailctl >/dev/null || { echo "‚ùå lightsailctl not found in PATH"; exit 1; }
          echo "‚úÖ lightsailctl installed successfully"

      - name: Set up Docker Buildx (optional)
        uses: docker/setup-buildx-action@v3

      - name: Docker cache
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      - name: Build images
        run: |
          set -euo pipefail
          docker buildx create --use
          docker buildx build -f backend/Dockerfile  -t backend:ci  --cache-from type=local,src=/tmp/.buildx-cache --cache-to type=local,dest=/tmp/.buildx-cache-new --load .
          docker buildx build -f frontend/Dockerfile -t frontend:ci --cache-from type=local,src=/tmp/.buildx-cache --cache-to type=local,dest=/tmp/.buildx-cache-new --load .
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Ensure Lightsail service exists (idempotent)
        run: |
          aws lightsail create-container-service \
            --region "${{ env.AWS_REGION }}" \
            --service-name "${{ env.SERVICE_NAME }}" \
            --power nano \
            --scale 1 || true

      - name: Push images to Lightsail (returns labels)
        id: push
        run: |
          set -euo pipefail

          # helper: extract lightsail label like :lightscore-prod.backend.12
          extract_label() {
          grep -oE ':[a-z0-9._-]+\.[a-z0-9._-]+\.[0-9]+' | tail -n1
          }

          echo "üö¢ Pushing backend image..."
          B_OUT=$(aws lightsail push-container-image \
          --region "${{ env.AWS_REGION }}" \
          --service-name "${{ env.SERVICE_NAME }}" \
          --label backend \
          --image backend:ci \
          --output text)

          echo "üö¢ Pushing frontend image..."
          F_OUT=$(aws lightsail push-container-image \
          --region "${{ env.AWS_REGION }}" \
          --service-name "${{ env.SERVICE_NAME }}" \
          --label frontend \
          --image frontend:ci \
          --output text)

          B_IMG=$(printf "%s" "$B_OUT" | extract_label)
          F_IMG=$(printf "%s" "$F_OUT" | extract_label)

          # Validate labels
          case "$B_IMG" in
          :*) ;;  *) echo "‚ùå Could not parse backend label from output"; echo "$B_OUT"; exit 1 ;; esac
          case "$F_IMG" in
          :*) ;;  *) echo "‚ùå Could not parse frontend label from output"; echo "$F_OUT"; exit 1 ;; esac

          echo "‚úÖ Backend image: $B_IMG"
          echo "‚úÖ Frontend image: $F_IMG"

          echo "BACKEND_IMG=$B_IMG"  >> "$GITHUB_OUTPUT"
          echo "FRONTEND_IMG=$F_IMG" >> "$GITHUB_OUTPUT"

      - name: Deploy containers to Lightsail
        id: deploy
        run: |
          set -euo pipefail

          B_IMG='${{ steps.push.outputs.BACKEND_IMG }}'
          F_IMG='${{ steps.push.outputs.FRONTEND_IMG }}'
          BP='${{ env.BACKEND_PORT }}'
          FP='${{ env.FRONTEND_PORT }}'
          REGION='${{ env.AWS_REGION }}'
          SVC='${{ env.SERVICE_NAME }}'

          # Basic sanity checks
          [[ -n "$B_IMG" ]] || { echo "‚ùå Backend image reference is empty"; exit 1; }
          [[ -n "$F_IMG" ]] || { echo "‚ùå Frontend image reference is empty"; exit 1; }

          # Lightsail label format like :lightscore-prod.backend.12
          is_label() { [[ "$1" =~ ^:[a-z0-9._-]+\.[a-z0-9._-]+\.[0-9]+$ ]]; }
          is_label "$B_IMG" || { echo "‚ùå Backend label looks wrong: $B_IMG"; exit 1; }
          is_label "$F_IMG" || { echo "‚ùå Frontend label looks wrong: $F_IMG"; exit 1; }

          echo "üöÄ Creating deployment..."
          aws lightsail create-container-service-deployment \
          --region "$REGION" \
          --service-name "$SVC" \
          --containers "$(
              jq -n --arg b "$B_IMG" --arg f "$F_IMG" --arg bp "$BP" --arg fp "$FP" --arg svc "$SVC" \
              '{ backend:  { image: $b, ports: {($bp): "HTTP"} },
                  frontend: { image: $f, ports: {($fp): "HTTP"},
                              environment: { BACKEND_URL: ("http://" + $svc + ".service.local:" + $bp) } } }'
          )" \
          --public-endpoint "$(
              jq -n --arg fp "$FP" \
              '{ containerName: "frontend",
                  containerPort: ($fp|tonumber),
                  healthCheck: { path:"/", intervalSeconds:10, timeoutSeconds:5, healthyThreshold:2, unhealthyThreshold:5 } }'
          )" \
          >/dev/null

          # Wait until service status is RUNNING and latest deployment is ACTIVE
          echo "‚è≥ Waiting for deployment to become ACTIVE..."
          for i in {1..20}; do
          STATUS=$(aws lightsail get-container-services \
              --region "$REGION" --service-name "$SVC" \
              --query 'containerServices[0].state' --output text)

          DEPLOY_STATUS=$(aws lightsail get-container-service-deployments \
              --region "$REGION" --service-name "$SVC" \
              --query 'deployments[0].state' --output text)

          echo "Attempt $i/20 ‚Üí service:$STATUS, deployment:$DEPLOY_STATUS"
          if [[ "$STATUS" == "RUNNING" && "$DEPLOY_STATUS" == "ACTIVE" ]]; then
              break
          fi
          sleep 15
          done

          if [[ "$STATUS" != "RUNNING" || "$DEPLOY_STATUS" != "ACTIVE" ]]; then
          echo "‚ùå Deployment did not become ACTIVE (service:$STATUS, deployment:$DEPLOY_STATUS)"
          echo "üîé Last operations:"
          aws lightsail get-operations --region "$REGION" --query 'operations[0:5].[status,operationType,resourceName,createdAt]' --output table || true
          exit 1
          fi

          URL=$(aws lightsail get-container-services \
          --region "$REGION" --service-name "$SVC" \
          --query 'containerServices[0].url' --output text)

          echo "‚úÖ Deployment ACTIVE ‚Üí $URL"
          echo "URL=$URL" >> "$GITHUB_OUTPUT"

      - name: Map custom domain (ensure cert, then attach)
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          DOMAIN_NAME: ${{ secrets.LIGHTSCORE_DOMAIN }}
        run: |
          set -euo pipefail

          if [ -z "${DOMAIN_NAME:-}" ]; then
            echo "‚ÑπÔ∏è Skipping domain attach: LIGHTSCORE_DOMAIN not set"
            exit 0
          fi

          MAP_JSON=$(jq -n --arg d "$DOMAIN_NAME" '{($d):[$d]}')
          # Try update; if it still 404s NotFound, sleep and retry once
          if ! aws lightsail update-container-service \
              --region "$AWS_REGION" \
              --service-name "$SERVICE_NAME" \
              --public-domain-names "$MAP_JSON" >/dev/null; then
            echo "‚è≥ Retry once after short wait..."
            sleep 10
            aws lightsail update-container-service \
              --region "$AWS_REGION" \
              --service-name "$SERVICE_NAME" \
              --public-domain-names "$MAP_JSON" >/dev/null
          fi

          echo "üîé Certificate status now:"
          aws lightsail get-container-services \
            --region "$AWS_REGION" --service-name "$SERVICE_NAME" \
            --query 'containerServices[0].publicEndpoint.certificate.{Domain:certificateDomainName,Status:certificateStatus,AltNames:certificateAlternativeNames}' \
            --output table

          SVC_URL=$(aws lightsail get-container-services \
            --region "$AWS_REGION" --service-name "$SERVICE_NAME" \
            --query 'containerServices[0].url' --output text)
          SVC_HOST=$(echo "$SVC_URL" | sed -E 's#https?://##' | cut -d/ -f1)
          echo "‚û°Ô∏è  DNS: keep/create CNAME"
          echo "    $DOMAIN_NAME  CNAME  $SVC_HOST"
