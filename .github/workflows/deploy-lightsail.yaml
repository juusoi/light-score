name: Deploy to Production

on:
  # Manual trigger OR automatic after security checks succeed on main
  workflow_dispatch: {}
  workflow_run:
    workflows: ['Security checks']
    types: [completed]
    branches: [main]
  # No pull_request trigger: deploy only after merge.

permissions:
  id-token: write
  contents: read
  actions: read

concurrency:
  group: prod-deploy
  cancel-in-progress: false

env:
  AWS_REGION: eu-north-1
  SERVICE_NAME: lightscore-prod
  FRONTEND_PORT: '5000'
  BACKEND_PORT: '8000'

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Change Detection
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  detect-changes:
    name: Check if app files changed
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.changes.outputs.should_deploy || steps.manual.outputs.should_deploy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect deployable changes
        id: changes
        if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const sha = context.payload.workflow_run.head_sha;
            const { owner, repo } = context.repo;

            // Get the commit to find its parent
            const { data: commit } = await github.rest.repos.getCommit({
              owner, repo, ref: sha
            });

            // Get files changed in this commit
            const changedFiles = commit.files?.map(f => f.filename) || [];
            core.info(`Changed files in ${sha}:`);
            changedFiles.forEach(f => core.info(`  - ${f}`));

            // Patterns that require deployment
            const deployPatterns = [
              /^backend\//,
              /^frontend\//,
              /^functions\//,
              /^terraform\//,
              /^compose\.yaml$/,
              /^pyproject\.toml$/,
              /^Makefile$/,
              /^uv\.lock$/,
            ];

            const shouldDeploy = changedFiles.some(file =>
              deployPatterns.some(pattern => pattern.test(file))
            );

            core.info(`\nShould deploy: ${shouldDeploy}`);
            core.setOutput('should_deploy', String(shouldDeploy));

            if (!shouldDeploy) {
              core.info('â„¹ï¸ No deployable changes detected. Skipping deployment.');
            }

      - name: Force deploy on manual trigger
        id: manual
        if: github.event_name != 'workflow_run'
        run: echo "should_deploy=true" >> "$GITHUB_OUTPUT"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Prerequisites Check
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  check-prerequisites:
    name: Verify CI and Security passed
    runs-on: ubuntu-latest
    needs: [detect-changes]
    outputs:
      deploy-ready: ${{ steps.check.outputs.ready || steps.manual_ready.outputs.ready }}
    steps:
      - name: Check workflow prerequisites
        id: check
        if: |
          github.event_name == 'workflow_run' && 
          github.event.workflow_run.conclusion == 'success' &&
          needs.detect-changes.outputs.should-deploy == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const sha = context.payload.workflow_run.head_sha;

            // Verify both CI and Security workflows passed for this commit
            const { data } = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, head_sha: sha, status: 'completed', per_page: 50
            });

            const findByName = (name) => data.workflow_runs.find(r => r.name === name);
            const ci = findByName('CI');
            const security = findByName('Security checks');

            const ciPassed = ci?.conclusion === 'success';
            const securityPassed = security?.conclusion === 'success';

            core.info(`CI passed: ${ciPassed}`);
            core.info(`Security passed: ${securityPassed}`);

            const ready = ciPassed && securityPassed;
            core.setOutput('ready', String(ready));

            if (!ready) {
              core.setFailed('Prerequisites not met: Both CI and Security workflows must pass');
            }

      - name: Mark ready for manual trigger
        id: manual_ready
        if: github.event_name != 'workflow_run'
        run: echo "ready=true" >> "$GITHUB_OUTPUT"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Infrastructure
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  terraform:
    name: Provision Lightsail Service
    runs-on: ubuntu-latest
    needs: [detect-changes, check-prerequisites]
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && 
       needs.detect-changes.outputs.should-deploy == 'true' &&
       needs.check-prerequisites.outputs.deploy-ready == 'true')
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: gh-terraform

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Initialize Terraform
        working-directory: ./terraform
        run: terraform init -input=false

      - name: Apply Terraform configuration
        working-directory: ./terraform
        run: terraform apply -auto-approve -input=false

      - name: Verify deployment
        working-directory: ./terraform
        run: |
          terraform state list | grep -q '^aws_lightsail_container_service\.svc$'
          echo "âœ… Infrastructure provisioned successfully"

      - name: Get service URL
        id: service
        working-directory: ./terraform
        run: |
          URL=$(terraform output -raw lightsail_service_url || true)
          echo "URL=$URL" >> $GITHUB_OUTPUT

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Application Deployment
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy:
    name: Build and Deploy Containers
    runs-on: ubuntu-latest
    needs: [detect-changes, check-prerequisites, terraform]
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && 
       needs.detect-changes.outputs.should-deploy == 'true' &&
       needs.check-prerequisites.outputs.deploy-ready == 'true')
    outputs:
      service_url: ${{ steps.deploy.outputs.URL }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: gh-deploy

      - name: Install lightsailctl
        run: |
          set -euo pipefail
          ARCH=linux-amd64
          BASE="https://s3.us-west-2.amazonaws.com/lightsailctl/latest/${ARCH}"
          TMP="$(mktemp -d)"

          # Download binary
          curl --proto '=https' --tlsv1.2 --retry 3 -fsSLo "${TMP}/lightsailctl" "${BASE}/lightsailctl"

          # Verify checksum if available
          if curl --proto '=https' --tlsv1.2 --retry 3 -fsSLo "${TMP}/lightsailctl.sha256" "${BASE}/lightsailctl.sha256" 2>/dev/null; then
            cd "${TMP}"
            if awk 'NF>=2{found=1} END{exit !found}' lightsailctl.sha256; then
              CHECKFILE="lightsailctl.sha256"
            else
              echo "$(tr -d ' \t\r\n' < lightsailctl.sha256)  lightsailctl" > sum.txt
              CHECKFILE="sum.txt"
            fi
            echo "âœ… Verifying checksum..."
            sha256sum -c "$CHECKFILE"
          else
            echo "âš ï¸ No checksum available, skipping verification"
          fi

          # Install to PATH
          mkdir -p "$HOME/.local/bin"
          mv "${TMP}/lightsailctl" "$HOME/.local/bin/lightsailctl"
          chmod +x "$HOME/.local/bin/lightsailctl"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

          echo "âœ… lightsailctl installed successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build Docker images
        run: |
          set -euo pipefail
          docker buildx create --use

          # Build both images with cache
          docker buildx build \
            -f backend/Dockerfile \
            -t backend:ci \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new \
            --load .
            
          docker buildx build \
            -f frontend/Dockerfile \
            -t frontend:ci \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new \
            --load .

          # Rotate cache
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Ensure Lightsail service exists
        run: |
          aws lightsail create-container-service \
            --region "${{ env.AWS_REGION }}" \
            --service-name "${{ env.SERVICE_NAME }}" \
            --power nano \
            --scale 1 || true

      - name: Push images to Lightsail
        id: push
        run: |
          set -euo pipefail

          # Helper function to extract Lightsail image labels
          extract_label() {
            grep -oE ':[a-z0-9._-]+\.[a-z0-9._-]+\.[0-9]+' | tail -n1
          }

          echo "ðŸš¢ Pushing backend image..."
          BACKEND_OUTPUT=$(aws lightsail push-container-image \
            --region "${{ env.AWS_REGION }}" \
            --service-name "${{ env.SERVICE_NAME }}" \
            --label backend \
            --image backend:ci \
            --output text)

          echo "ðŸš¢ Pushing frontend image..."
          FRONTEND_OUTPUT=$(aws lightsail push-container-image \
            --region "${{ env.AWS_REGION }}" \
            --service-name "${{ env.SERVICE_NAME }}" \
            --label frontend \
            --image frontend:ci \
            --output text)

          # Extract image labels
          BACKEND_IMG=$(printf "%s" "$BACKEND_OUTPUT" | extract_label)
          FRONTEND_IMG=$(printf "%s" "$FRONTEND_OUTPUT" | extract_label)

          # Validate labels
          [[ "$BACKEND_IMG" =~ ^: ]] || { 
            echo "âŒ Invalid backend label: $BACKEND_IMG"
            echo "Output: $BACKEND_OUTPUT"
            exit 1 
          }
          [[ "$FRONTEND_IMG" =~ ^: ]] || { 
            echo "âŒ Invalid frontend label: $FRONTEND_IMG"
            echo "Output: $FRONTEND_OUTPUT"
            exit 1 
          }

          echo "âœ… Backend image: $BACKEND_IMG"
          echo "âœ… Frontend image: $FRONTEND_IMG"

          echo "BACKEND_IMG=$BACKEND_IMG" >> "$GITHUB_OUTPUT"
          echo "FRONTEND_IMG=$FRONTEND_IMG" >> "$GITHUB_OUTPUT"

      - name: Deploy containers to Lightsail
        id: deploy
        env:
          BACKEND_IMG: ${{ steps.push.outputs.BACKEND_IMG }}
          FRONTEND_IMG: ${{ steps.push.outputs.FRONTEND_IMG }}
        run: |
          set -euo pipefail

          # Validate image references
          [[ -n "$BACKEND_IMG" && "$BACKEND_IMG" =~ ^:[a-z0-9._-]+\.[a-z0-9._-]+\.[0-9]+$ ]] || {
            echo "âŒ Invalid backend image reference: $BACKEND_IMG"
            exit 1
          }
          [[ -n "$FRONTEND_IMG" && "$FRONTEND_IMG" =~ ^:[a-z0-9._-]+\.[a-z0-9._-]+\.[0-9]+$ ]] || {
            echo "âŒ Invalid frontend image reference: $FRONTEND_IMG"
            exit 1
          }

          echo "ðŸš€ Creating deployment..."

          # Create container configuration
          CONTAINERS=$(jq -n \
            --arg backend_img "$BACKEND_IMG" \
            --arg frontend_img "$FRONTEND_IMG" \
            --arg backend_port "${{ env.BACKEND_PORT }}" \
            --arg frontend_port "${{ env.FRONTEND_PORT }}" \
            --arg service_name "${{ env.SERVICE_NAME }}" \
            '{
              backend: {
                image: $backend_img,
                ports: {($backend_port): "HTTP"}
              },
              frontend: {
                image: $frontend_img,
                ports: {($frontend_port): "HTTP"},
                environment: {
                  BACKEND_URL: ("http://" + $service_name + ".service.local:" + $backend_port)
                }
              }
            }')

          # Create public endpoint configuration
          PUBLIC_ENDPOINT=$(jq -n \
            --arg frontend_port "${{ env.FRONTEND_PORT }}" \
            '{
              containerName: "frontend",
              containerPort: ($frontend_port|tonumber),
              healthCheck: {
                path: "/",
                intervalSeconds: 10,
                timeoutSeconds: 5,
                healthyThreshold: 2,
                unhealthyThreshold: 5
              }
            }')

          # Deploy to Lightsail
          aws lightsail create-container-service-deployment \
            --region "${{ env.AWS_REGION }}" \
            --service-name "${{ env.SERVICE_NAME }}" \
            --containers "$CONTAINERS" \
            --public-endpoint "$PUBLIC_ENDPOINT" \
            >/dev/null

          # Wait for deployment to become active
          echo "â³ Waiting for deployment to become ACTIVE..."
          for i in {1..30}; do
            SERVICE_STATUS=$(aws lightsail get-container-services \
              --region "${{ env.AWS_REGION }}" \
              --service-name "${{ env.SERVICE_NAME }}" \
              --query 'containerServices[0].state' \
              --output text)

            DEPLOYMENT_STATUS=$(aws lightsail get-container-service-deployments \
              --region "${{ env.AWS_REGION }}" \
              --service-name "${{ env.SERVICE_NAME }}" \
              --query 'deployments[0].state' \
              --output text)

            echo "Attempt $i/30 â†’ service: $SERVICE_STATUS, deployment: $DEPLOYMENT_STATUS"
            
            if [[ "$SERVICE_STATUS" == "RUNNING" && "$DEPLOYMENT_STATUS" == "ACTIVE" ]]; then
              break
            fi
            sleep 10
          done

          # Verify final status
          if [[ "$SERVICE_STATUS" != "RUNNING" || "$DEPLOYMENT_STATUS" != "ACTIVE" ]]; then
            echo "âŒ Deployment failed (service: $SERVICE_STATUS, deployment: $DEPLOYMENT_STATUS)"
            echo "Recent operations:"
            aws lightsail get-operations \
              --region "${{ env.AWS_REGION }}" \
              --query 'operations[0:5].[status,operationType,resourceName,createdAt]' \
              --output table || true
            exit 1
          fi

          # Get service URL
          SERVICE_URL=$(aws lightsail get-container-services \
            --region "${{ env.AWS_REGION }}" \
            --service-name "${{ env.SERVICE_NAME }}" \
            --query 'containerServices[0].url' \
            --output text)

          echo "âœ… Deployment successful â†’ $SERVICE_URL"
          echo "URL=$SERVICE_URL" >> "$GITHUB_OUTPUT"

      - name: Configure custom domain
        env:
          DOMAIN_NAME: ${{ secrets.LIGHTSCORE_DOMAIN }}
        run: |
          set -euo pipefail

          if [[ -z "${DOMAIN_NAME:-}" ]]; then
            echo "â„¹ï¸ Skipping domain configuration: LIGHTSCORE_DOMAIN not set"
            exit 0
          fi

          echo "ðŸŒ Configuring custom domain: $DOMAIN_NAME"

          DOMAIN_CONFIG=$(jq -n --arg domain "$DOMAIN_NAME" '{($domain): [$domain]}')

          # Attempt to update domain configuration with retry
          if ! aws lightsail update-container-service \
              --region "${{ env.AWS_REGION }}" \
              --service-name "${{ env.SERVICE_NAME }}" \
              --public-domain-names "$DOMAIN_CONFIG" >/dev/null; then
            echo "â³ Retrying domain configuration..."
            sleep 10
            aws lightsail update-container-service \
              --region "${{ env.AWS_REGION }}" \
              --service-name "${{ env.SERVICE_NAME }}" \
              --public-domain-names "$DOMAIN_CONFIG" >/dev/null
          fi

          echo "âœ… Custom domain configured successfully"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Post-Deployment Smoke Tests (uses reusable E2E workflow)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  e2e-smoke:
    name: E2E Smoke Tests
    needs: [deploy]
    uses: ./.github/workflows/e2e-manual.yaml
    with:
      target: production
      test_suite: smoke
      browser: chromium
    secrets:
      PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}

